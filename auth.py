"""
JWT Authentication Module for Simpson Pipeline Backend

This module provides JWT token validation and authentication
for protecting API endpoints. Validates JWT tokens generated
by NextAuth on the frontend.
"""

import os
import jwt
from fastapi import Depends, HTTPException, status
from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials
from typing import Optional, Dict
from dotenv import load_dotenv

load_dotenv()

# JWT Configuration (must match NextAuth AUTH_SECRET)
JWT_SECRET_KEY = os.getenv("JWT_SECRET_KEY")
JWT_ALGORITHM = os.getenv("JWT_ALGORITHM", "HS256")

if not JWT_SECRET_KEY:
    raise RuntimeError("JWT_SECRET_KEY not set in .env file")

# Security scheme
security = HTTPBearer()


def verify_token(token: str) -> Dict:
    """
    Verify JWT token and return decoded payload.
    
    This validates tokens generated by NextAuth on the frontend.
    The token should contain user information (id, email, name, etc.)
    
    Args:
        token: JWT token string from Authorization header
        
    Returns:
        Decoded token payload containing user data
        
    Raises:
        HTTPException: If token is invalid, expired, or malformed
    """
    try:
        # Decode and verify the token
        payload = jwt.decode(
            token,
            JWT_SECRET_KEY,
            algorithms=[JWT_ALGORITHM],
            options={
                "verify_signature": True,
                "verify_exp": True,  # Verify expiration
                "require": ["exp"]   # Require expiration claim
            }
        )
        
        # Validate required fields from NextAuth token
        user_id = payload.get("id")
        user_email = payload.get("email")
        user_name = payload.get("name")
        
        # Check for required fields
        missing_fields = []
        if not user_id:
            missing_fields.append("id")
        if not user_email:
            missing_fields.append("email")
        if not user_name:
            missing_fields.append("name")
        
        if missing_fields:
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail=f"Token missing required fields: {', '.join(missing_fields)}",
                headers={"WWW-Authenticate": "Bearer"},
            )
        
        # Log successful authentication (optional, for debugging)
        print(f"✅ Authenticated user: {user_id} ({user_email})")
        
        # accessToken is optional, no validation needed
        return payload
        
    except jwt.ExpiredSignatureError:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Token has expired. Please log in again.",
            headers={"WWW-Authenticate": "Bearer"},
        )
    except jwt.InvalidSignatureError:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid token signature. Authentication failed.",
            headers={"WWW-Authenticate": "Bearer"},
        )
    except jwt.DecodeError:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Token is malformed. Please log in again.",
            headers={"WWW-Authenticate": "Bearer"},
        )
    except HTTPException:
        # Re-raise HTTPExceptions (like missing fields)
        raise
    except Exception as e:
        print(f"⚠️ Token validation error: {str(e)}")
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Authentication failed. Please log in again.",
            headers={"WWW-Authenticate": "Bearer"},
        )


def get_current_user(
    credentials: HTTPAuthorizationCredentials = Depends(security)
) -> Dict:
    """
    FastAPI dependency for protecting endpoints with JWT authentication.
    
    Validates the JWT token from the Authorization header and returns
    the user information from the token payload.
    
    Usage:
        @app.get("/protected")
        def protected_route(user: Dict = Depends(get_current_user)):
            return {"user_id": user.get("id")}
    
    Args:
        credentials: HTTP Authorization credentials from request header
        
    Returns:
        Decoded token payload containing user information
        
    Raises:
        HTTPException: If token is missing or invalid
    """
    token = credentials.credentials
    return verify_token(token)
